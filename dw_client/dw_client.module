<?php

/**
 * @file
 *   Drupal Watchtower client module. Provides watchtower-reporting
 *   functionality.
 */

/**
 * Default minimal period of time in seconds between reports executed by cron.
 */
define('WATCHTOWER_DEFAULT_REPORT_THRESHOLD', 10800);

/**
 * Implements hook_menu().
 */
function dw_client_menu() {
  $items = array();
  $items['admin/config/system/watchtower_client'] = array(
    'title' => 'Drupal Watchtower Client settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dw_client_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'dw_client.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_hook_info().
 */
function dw_client_hook_info() {
  $hooks['dw_metric'] = array(
    'group' => 'metric',
  );
  return $hooks;
}

/**
 * Implements hook_cron().
 */
function dw_client_cron() {
  _dw_client_report();
}

/**
 * Implements hook_modules_enabled().
 */
function dw_client_modules_enabled($modules) {
  if (variable_get('watchtower_on_modules_events', FALSE)) {
    _dw_client_report(TRUE);
  }
}

/**
 * Implements hook_modules_disabled().
 */
function dw_client_modules_disabled($modules) {
  if (variable_get('watchtower_on_modules_events', FALSE)) {
    _dw_client_report(TRUE);
  }
}

/**
 * Sends state report to watchtower server.
 *
 * @todo Refactor for better integration with drush.
 *
 * @param bool $force
 *   Do not check the last report time.
 *
 * @return bool
 *   Is result successful.
 */
function _dw_client_report($force = FALSE) {
  if ($watchtower = variable_get('watchtower_server', FALSE)) {
    if ($force || (time() - variable_get('watchtower_last_report', 0) >= variable_get('watchtower_report_threshold', WATCHTOWER_DEFAULT_REPORT_THRESHOLD))) {
      $instance_report = array(
        'watchtower_key' => md5(drupal_get_private_key()),
        'drupal_root' => DRUPAL_ROOT . '/' . conf_path(),
        'modules' => dw_client_loaded_modules(),
        'patches' => dw_client_patches(),
        'metrics' => module_invoke_all('dw_metric'),
      );

      $result = xmlrpc($watchtower, array(
        'drupal_watchtower.report' => array($instance_report),
      ));

      if (!$result) {
        watchdog('dw_client', xmlrpc_error_msg(), array(), WATCHDOG_ERROR);
      }
      else {
        variable_set('watchtower_last_report', time());
        variable_set('watchtower_instance_info_url', $result);
      }
    }
  }
  return !empty($result);
}

/**
 * Collects data about enabled modules.
 *
 * @return array
 */
function dw_client_loaded_modules() {
  $modules = dw_client_get_enabled_not_hidden_non_core_modules();

  // Reformat modules list.
  array_walk($modules, 'dw_client_modules_array_format');

  return $modules;
}

/**
 * Retrieves list of enabled not hidden non-core modules.
 *
 * @return mixed
 */
function dw_client_get_enabled_not_hidden_non_core_modules() {
  $modules = &drupal_static(__FUNCTION__, '');

  if (!$modules) {
    // Get current list of modules.
    $modules = system_rebuild_module_data();

    // Remove hidden, disabled and core modules from display list.
    foreach ($modules as $filename => $module) {
      if (!empty($module->info['hidden']) || !$module->status || $module->info['package'] == 'Core') {
        unset($modules[$filename]);
      }
    }
  }

  return $modules;
}

/**
 * Helper function to use with array_walk.
 * Formats modules array.
 *
 * @param $item
 * @param $key
 */
function dw_client_modules_array_format(&$item, $key) {
  $item = (object) array(
    'name' => $item->info['name'],
    'machine_name' => $key,
    'description' => $item->info['description'],
    'package' => $item->info['package'],
    'version' => $item->info['version'],
  );
}

/**
 * Retrieves patches for enabled modules to report to Watchtower server.
 *
 * @return array
 */
function dw_client_patches() {
  $patches = array();
  $modules = dw_client_get_enabled_not_hidden_non_core_modules();
  $_patched_modules = dw_client_search_patches($modules);
  foreach ($_patched_modules as $module_name => $module_patches) {
    foreach ($module_patches as $patchname) {
      $patches[$patchname] = $module_name;
    }
  }

  return $patches;
}

/**
 * Retrieves patches for a list of modules grouped by module version name.
 *
 * @param array $modules
 *   List of modules in format of system_rebuild_module_data() function.
 * @param bool $recursive
 *   Flag defining that patches should be searched recursively inside modules'
 *   directories.
 *
 * @return array
 */
function dw_client_search_patches($modules, $recursive = FALSE) {
  $patches = array();
  foreach ($modules as $module_name => $module) {
    $module_version_name = $module_name . '-' . $module->info['version'];
    $module_path = dirname($module->filename);
    $module_patches = array();
    if ($recursive) {
      // Recursive version - looks thru whole module directory structure
      $directory = new RecursiveDirectoryIterator($module_path);
      $flattened = new RecursiveIteratorIterator($directory);
      $files = new RegexIterator($flattened, '/.*\.patch/i');
      foreach ($files as $file) {
        $module_patches[] = $file->getPath();
      }
    }
    else {
      // Non-recursive version - only modules root directory to be scanned
      $module_patches = glob($module_path . '/*.patch');
    }

    if ($module_patches) {
      foreach ($module_patches as &$patch_path) {
        $patch_path = basename($patch_path);
      }
      $patches[$module_name . ':' . $module_version_name] = $module_patches;
    }
  }

  return $patches;
}
