<?php

/**
 * @file
 *   Drupal Watchtower client module. Provides watchtower-reporting
 *   functionality.
 */

use Drupal\Component\Utility\Crypt;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Site\Settings;

/**
 * Implements hook_help().
 */
function dw_client_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.dw_client':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The module allows sending reports to Watchtower server.') . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Configure settings') . '</dt>';
      $output .= '<dd>' . t('Administrators can configure automatic report send at <a href="!link">Watchtower administration page</a>.', [
        '!link' => \Drupal::url('dw_client.settings_form'),
        ]) . '</dd>';
      $output .= '<dt>' . t('Configuring cron') . '</dt>';
      $output .= '<dd>' . t('A working <a href="!cron">cron maintenance task</a> is required to send reports automatically.', [
          '!cron' => \Drupal::url('system.cron_settings'),
        ]) . '</dd>';
      $output .= '</dl>';
      return $output;

    case 'dw_client.settings_form':
      return t('Configure server and schedule time to send reports');
  }
}

/**
 * Implements hook_hook_info().
 */
function dw_client_hook_info() {
  $hooks['dw_metric'] = array(
    'group' => 'metric',
  );
  return $hooks;
}

/**
 * Implements hook_cron().
 */
function dw_client_cron() {
  $config = \Drupal::config('dw_client.settings');
  if ($config->get('schedule') && $config->get('url')) {
    _dw_client_report();
  }
}

/**
 * Implements hook_modules_installed().
 */
function dw_client_modules_installed($modules) {
  if (\Drupal::state()->get('dw_client.report_url')) {
    $events = \Drupal::config('dw_client.settings')->get('events');
    if (!empty($events['modules'])) {
      _dw_client_report(TRUE);
    }
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function dw_client_modules_uninstalled($modules) {
  if (\Drupal::state()->get('dw_client.report_url')) {
    $events = \Drupal::config('dw_client.settings')->get('events');
    if (!empty($events['modules'])) {
      _dw_client_report(TRUE);
    }
  }
}

/**
 * Sends state report to watchtower server.
 *
 * @todo Refactor for better integration with drush.
 *
 * @param bool $force
 *   Do not check the last report time.
 * @param string $url
 *   (Optional) the URL to use, default will use configured.
 *
 * @return bool
 *   Is result successful.
 */
function _dw_client_report($force = FALSE, $url = '') {
  $time = time();
  $config = \Drupal::config('dw_client.settings');
  $last_run = \Drupal::state()->get('dw_client.report_last', 0);
  if ($url) {
    $watchtower = $url;
  }
  else {
    $watchtower = $config->get('url');
  }
  if ($watchtower) {
    if ($force || ($time - $last_run >= $config->get('report_threshold'))) {
      $private_key = \Drupal::service('private_key')->get();
      $hash_salt = Settings::getHashSalt();
      $drupal_root = DRUPAL_ROOT;
      $conf_path = conf_path();
      $report = [
        // @todo Use better hash.
        'watchtower_key' => Crypt::hmacBase64('Watchtower', $private_key . $hash_salt),
        // @todo Revisit deprecated.
        'drupal_root' => $drupal_root,
        'conf_path' => $conf_path,
        'metrics' => [
          // Add standard metrics.
          'php:version' => phpversion(),
          'php:max_execution_time' => ini_get('max_execution_time'),
          'php:memory_limit' => ini_get('memory_limit'),
          'site:core:version' => \Drupal::VERSION,
        ],
      ];

      $report['metrics']['dw_client:modules'] = dw_client_loaded_modules();
      $report['metrics']['dw_client:patches'] = dw_client_patches();
      $report['metrics']['dw_client:metrics'] = \Drupal::moduleHandler()->invokeAll('dw_metric');

      $result = xmlrpc($watchtower, array(
        'drupal_watchtower.report' => array($report),
      ));

      // Any execution should set it's mark.
      \Drupal::state()->set('dw_client.report_last',$time);
      if ($result) {
        \Drupal::state()->set('dw_client.report_url',$result);
      }
      else {
        \Drupal::state()->delete('dw_client.report_url');
        \Drupal::logger('dw_client')->error(xmlrpc_error_msg() ?: 'No message');
      }
    }
  }
  return !empty($result);
}

/**
 * Collects data about enabled modules.
 *
 * @return array
 */
function dw_client_loaded_modules() {
  $modules = dw_client_get_enabled_not_hidden_non_core_modules();

  // Reformat modules list.
  array_walk($modules, 'dw_client_modules_array_format');

  return $modules;
}

/**
 * Retrieves list of enabled not hidden non-core modules.
 *
 * @return \Drupal\Core\Extension\Extension[]
 *   Array of enabled modules without core ones.
 */
function dw_client_get_enabled_not_hidden_non_core_modules() {
  $modules = &drupal_static(__FUNCTION__, []);

  if (!$modules) {
    // Get current list of modules.
    // @todo $modules = \Drupal::moduleHandler()->getModuleList();
    $modules = system_rebuild_module_data();

    // Remove hidden, disabled and core modules from display list.
    foreach ($modules as $name => $module) {
      if (!$module->status || $module->origin === 'core') {
        // Filter out core modules.
        unset($modules[$name]);
      }
    }
  }

  return $modules;
}

/**
 * Helper function to use with array_walk.
 * Formats modules array.
 *
 * @param \Drupal\Core\Extension\Extension $item
 *   The module extension to format
 * @param string $name
 *   The module machine name.
 */
function dw_client_modules_array_format(&$item, $name) {
  $item = (object) array(
    'name' => $item->info['name'],
    // 'machine_name' => $name,
    // 'description' => $item->info['description'],
    'package' => $item->info['package'],
    'version' => $item->info['version'],
  );
}

/**
 * Retrieves patches for enabled modules to report to Watchtower server.
 *
 * @return array
 */
function dw_client_patches() {
  $patches = array();
  $modules = dw_client_get_enabled_not_hidden_non_core_modules();
  $_patched_modules = dw_client_search_patches($modules);
  foreach ($_patched_modules as $module_name => $module_patches) {
    foreach ($module_patches as $patchname) {
      $patches[$patchname] = $module_name;
    }
  }

  return $patches;
}

/**
 * Retrieves patches for a list of modules grouped by module version name.
 *
 * @param \Drupal\Core\Extension\Extension[] $modules
 *   List of modules in format of system_rebuild_module_data() function.
 * @param bool $recursive
 *   Flag defining that patches should be searched recursively inside modules'
 *   directories.
 *
 * @return array
 */
function dw_client_search_patches($modules, $recursive = FALSE) {
  $patches = array();
  foreach ($modules as $module_name => $module) {
    $module_version_name = $module_name . ':' . $module->info['version'];
    $module_path = $module->getPath();
    $module_patches = array();
    if ($recursive) {
      // Recursive version - looks through whole module directory structure
      $directory = new \RecursiveDirectoryIterator($module_path);
      $flattened = new \RecursiveIteratorIterator($directory);
      $files = new \RegexIterator($flattened, '/.*\.patch/i');
      foreach ($files as $file) {
        $module_patches[] = $file->getPath();
      }
    }
    else {
      // Non-recursive version - only modules root directory to be scanned
      $module_patches = glob($module_path . '/*.patch');
    }

    if ($module_patches) {
      foreach ($module_patches as &$patch_path) {
        $patch_path = basename($patch_path);
      }
      $patches[$module_version_name] = $module_patches;
    }
  }

  return $patches;
}
