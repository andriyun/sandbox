<?php

/**
 * @file
 *   Base Drupal Watchtower server module.
 */

/**
 * Implements hook_help().
 */
function dw_server_help($path, $arg) {
  switch ($path) {
    case 'admin/help#dw_server':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Watchtower server module provides storage for site reports') . '</p>';
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 *
 * The function handles messages and access handling.
 */
function dw_server_menu() {
  // Get user API key for remote submissions.
  $items['watchtower/key/%'] = array(
    'title' => 'Your API key',
    'page callback' => 'dw_server_key_page',
    'page arguments' => array(2),
    'access arguments' => array('watchtower submit reports'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Generate API key for user, given a public client token sent over.
 *
 * @param string $client_token
 *   The client token to generate hash.
 *
 * @return array
 *   Build array for render.
 */
function dw_server_key_page($client_token) {
  global $user;
  $build['api_key'] = array(
    '#type' => 'item',
    '#title' => t('Your Watchtower Server API key'),
    '#markup' => dw_server_user_api_key($user->uid, $client_token),
    '#description' => t('Copy and paste this API key into client settings on the client host.'),
  );
  return $build;
}

/**
 * Implements hook_permission().
 */
function dw_server_permission() {
  return array(
    'watchtower submit reports' => array(
      'title' => t('Submit watchtower reports')
    ),
  );
}

/**
 * Implements hook_xmlrpc().
 */
function dw_server_xmlrpc() {
  return array(
    array(
      'drupal_watchtower.status',
      'dw_server_xmlrpc_status',
      array('struct', 'string', 'string', 'string'),
      t('Test support for a specific API version.'),
    ),
    array(
      'drupal_watchtower.report',
      'dw_server_process_report',
      array('string', 'struct', 'int', 'string', 'string'),
      t('Handle remote instance submissions.'),
    ),
  );
}

/**
 * Get API key for remote submission.
 *
 * This API key will contain a visible user id and a signature from the server.
 *
 * @param int $uid
 *   The local UID.
 * @param string $salt
 *   A signature from remote host.
 *
 * @return string
 *   The API key for user with passed in salt.
 */
function dw_server_user_api_key($uid, $salt) {
  $private_key = drupal_get_private_key();
  $hash_salt = drupal_get_hash_salt();
  return $uid . ':' . drupal_hmac_base64("Watchtower:$uid:$salt", $private_key . $hash_salt);
}

/**
 * XML-RPC callback to test the interface from the client.
 *
 * Returns:
 *  - 'service': Service name
 *  - 'version': Service version
 *  - 'name': Site name
 *  - 'features': Accepted reports (tbd)
 *  - 'supported': Whether the asked version is supported or not
 *  - 'valid': Whether the asked token is valid or not
 */
function dw_server_xmlrpc_status($version, $client_token, $api_key) {
  $authorized = FALSE;
  // Format should be UID:HASH string.
  $api_values = explode(':', $api_key);
  if (count($api_values) == 2) {
    // @todo Move to separate method to prevent brute force attacks, flood?.
    $authorized = dw_server_user_api_key($api_values[0], $client_token) === $api_key;
  }
  return array(
    // Watchtower server data.
    'service' => 'Watchtower reports collector interface',
    'version' => '1.0',
    'supported' => $version === '1.0',
    'features' => implode(', ', array('modules', 'patches')),
    // Website data.
    'name' => variable_get('site_name', 'Drupal'),
    'auth' => $authorized,
  );
}

/**
 * Processes XML RPC request
 *
 * @param array $report
 *   The data from client.
 * @param int $uid
 *   The UID at the server or 0 for drush API key.
 * @param string $client_token
 *   The site hash or user API key.
 * @param string $signature
 *   The signature for report.
 *
 * @return string|object
 *   New report node URL or error object.
 */
function dw_server_process_report($report, $uid, $client_token, $signature) {
  if (empty($uid)) {
    // Drush reports are signed with personal API keys.
    list($uid, ) = explode(':', $client_token);
    $account = user_load($uid);
    if ($account && $account->status) {
      // Check API key for user's current mail.
      $api_key = dw_server_user_api_key($account->uid, $account->mail);
      if ($api_key === $client_token) {
        $current_signature = md5($api_key . $report['watchtower_key'] . $report['drupal_root'] . $report['conf_path']);
      }
    }
  }
  else {
    // Client module API key.
    $api_key = dw_server_user_api_key($uid, $client_token);
    $current_signature = md5($api_key . $report['watchtower_key'] . $report['drupal_root'] . $report['conf_path'] . $client_token);
  }

  // Check the report signature.
  if (!isset($current_signature) || $current_signature !== $signature) {
    // @todo Add flood support.
    return xmlrpc_error(-32500, t('Signature error'));
  }

  module_load_include('inc', 'dw_server', 'dw_server.xmlrpc');

  $default = array(
    'watchtower_key' => '',
    'drupal_root' => '',
    'conf_path' => '',
    'metrics' => array(),
  );
  $data = drupal_array_merge_deep($default, $report);

  $node = _dw_server_get_instance($data['watchtower_key'], $data['drupal_root'], $data['conf_path'], ip_address());

  // Assign owner of report.
  // @todo Set current user to assign author for content.
  $node->get('author')->set($uid);

  $metrics = $data['metrics'];
  // Fills field_modules field.
  if (isset($metrics['site:modules'])) {
    $modules = $metrics['site:modules'];
    unset($metrics['site:modules']);
    ksort($modules);
    if ($modules = _dw_server_get_modules_tids($modules)) {
      $node->get('field_modules')->set($modules);
    }
  }

  // Fills field_patches field.
  if (isset($metrics['site:patches'])) {
    $patches = $metrics['site:patches'];
    unset($metrics['site:patches']);
    if ($patches = _dw_server_get_patches_nids($patches)) {
      $node->get('field_patches')->set($patches);
    }
  }

  // Keep metrics ordered.
  ksort($metrics);


  // Store core version in separate field for filtering.
  if (isset($metrics['site:core:version'])) {
    $node->get('field_core_version')->set($metrics['site:core:version']);
  }
  // Populate site domain.
  if (isset($metrics['site:core:base_url'])) {
    $node->get('field_domain')->set($metrics['site:core:base_url']);
  }

  // Fills field_metrics field.
  $metrics_save = array();
  foreach ($metrics as $k => $v) {
    $metrics_save[] = $k . ' = ' . $v;
  }
  $node->get('field_metrics')->set($metrics_save);

  $node->revision = TRUE;
  $node->save();

  return url('node/' . $node->get('nid')->value(), array('absolute' => TRUE));
}

/**
 * Implements hook_user_view().
 *
 * Displays personal API key to send reports with drush.
 */
function dw_server_user_view($account, $view_mode, $langcode) {
  if (user_access('submit watchtower reports', $account) && $view_mode == 'full') {
    $account->content['summary']['watchtower'] =  array(
      '#type' => 'user_profile_item',
      '#title' => t('Watchtower personal key'),
      // @todo Check that mail is good enough salt.
      '#markup' => dw_server_user_api_key($account->uid, $account->mail),
      '#attributes' => array('class' => array('watchtower')),
    );
  }
}
